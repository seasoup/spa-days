What we want:

FEATURE MODULE LEVEL

We should prefer to use an abstracted inteface from the model,
with perhaps the model maintaining and coordinating any global chat
artifacts. A key aspect of the implementation should be that data and model
layers should always be independent from the DOM.  Therefore, we will want
to use callbacks:

  spa.model.people.make_user( <name> );
  spa.model.chat.join();
  spa.model.chat.set_chatee( 'fred' );

  // set callbacks for various events
  spa.model.chat.add_callback( 'listchange', listChangeCb );
  spa.model.chat.add_callback( 'chat',       chatCb );
  spa.model.chat.add_callback( 'updatechat', updateChatCb );

  // ... later ...

  spa.model.chat.send_msg( ... );

There is some question of the concept of chat rooms, which we can discuss.
It may be that only a single chatroom is supported in our implementation.
Will need to explore.

NOTES FOR MODEL

Global event have greatly improved over the last year in performance.  See
http://stackoverflow.com/questions/3162748/jquery-global-events-and-performance.
There is no good reason not to use them.

When message is received for a user, an 'updatechat' event is received by
the by the sio object.  This contains the username and message text
as arugments.

VARIOUS CLIENT CODE CONCEPTS

  // for model: code to clean out output or input lists
  var revised_list = [], $field;
  FIELD:
  for ( i = 0; i < field_$list.length; i++ ){
    $field = field_$list[i];
    if ( $field.closest('body') === 0 ){ continue FIELD; }
    revise_list.push( $field );
  }
  // and revised_list now has all existant elements

When user types in a message and presses return, we get an on-submit event and
we can send the message with spa.model.chat.send_msg(...);
Use event.which for keyboard events, as it is the most robust.

NOTES 2012-09-30 per Josh:

user comes to page:
 - gets name
 - client.emit( 'adduser', name );

client emits 'listchange' to all connected clients
  package: list of users in response_list[0][n].name

User inputs a message.
client emits a 'chat' with this argument:
 { user : name, message : msg_text, chatee : chatee.name };

Server receives chat and looks up the chatter list
server emits 'updatechat' to chatee only with originating username and
message.

If chatee is offline, Server emits back to originating client an 'updatechat'
event with 'spa' as username, and message indicates it target chattee is
offline.

When client is closed, should emit a 'leavechat' event.  Server removes user
and then emits a 'listchange' to all connected clients.
package: list of users in response_list[0][n].name


